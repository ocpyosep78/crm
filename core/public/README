/core/public is where developers can study the API of the framework, modify its behaviour and extend it by adding module definitions among other possible extensions. For a complete documentation of the framework, see /core/private/README



NOTE: as of today, mar 24th 2011, most of the things described in this sheet are already working. However, a few things are still under development, and this notes respond more to planification than to the actual state of the framework (i.e. Modules library). I expect to have all that's described here ready for may 1st, and add then the API documentation (I'm not writing it untill Modules is ready, as it's probably the most important library in the framework).




AppTemplate (AT) OVERVIEW

AppTemplate (AT from now on) is a framework designed to facilitate the creation of new pages in a web application. The core of its philosophy is the DRY principle: Don't Repeat Yourself! Applications might defer here and there, each page is unique in a sense, alright, but if we abstract from the actual content of a page, most of it is present a thousand times in each and every application around. So we have a module called users? What pages should it have? What actions should it be possible to perform on or with it? Let's see... an information page, a page to edit a user, a page to list them all, a page to create a new user, and those bring some actions to mind too: editing, deleting, creating, blocking, sorting a list, paginating large lists, jumping from one item to another in one click, showing a tooltip with info of a particular item when hovering it in the list, presenting any of those pages in a small popup-like window when we are in the middle of something else and just need to have a quick look.

Wouldn't it be great if all of these could be created by filling a definition template for the module users? Or for any other module we might think of? Well, that is exactly what AT is about... in part.

After spending countless days and weeks designing, coding, then redesigning and editing again the ways the application should behave when navigating, you have to admit that navigation should be a centralized matter, totally automated, as easy as calling getPage(somePage). Well, it is that easy with AT. You can forget about the obscure background for ajax, caching, iframes loading, javascript namespace handling, loading the right stylesheets and the right scripts, getting the right template. All that is done automatically, as long as you follow a few simple rules (file location and naming conventions, that's all you need).

When developing a web application, permissions use to be a pain in the neck. Who hasn't forgotten to add something like

if( !userCanAccess(someCodeForThisPageOrAction) ) die('Access restricted')

or some more elegant ways to let the user know he's in the wrong place. Or having to check in each and every page what module to show in the navigation bar, which elements show in the menu, which ones to hide, which buttons to enable/disable/show/hide.

Permissions in AT are handled centrally and mostly automatically, and all you need to do is register a particular permission in the database (through the application itself, on a page shown only to developers) to have it working and fixing everything in the background without a single line of code. Of course, if you need to set exceptions, or aliases (let's say two pages share the same permission, or a page, two actions, a module, 4 alerts, whatever) you got it in a simple call to a method of the right class.

Creating and initializing the same object over and over again, I've seen it too often. Your application runs mostly on ajax, and each time you want to process a request you create the response object, fill it, pass it as parameter up and down untill you have no idea where it came from? The most often used objects in AT are accessed through a shortcut o{nameOfTheObject} and those that need to act as singletons do. For example, adding script execution to an ajax response is as easy as calling oXajax()->script("someScriptToRunClientSide").

So you wanted to add a few pages to deal with invoices, and you decide that goes in its own module. You're going to hack on a complicated centralized script that handles what to include where, to register your new pages, to tell it what image to use for that module, to add the module itself to the navigation bar, to add the menu items you need... Nothing of that is needed. Just go to the config module (in your browser, after logging as master in the application) and add a module invoices. Tell it what pages it will have, and what module it'll belong to. After creating the definition file, all those pages will be running, and AT will know where to look for them, what to show and to whom (provided you set the permissions too).

AT has a developer mode, that is always on in your working directory as long as you have a /core/public/local.cfg.php file with a constant DEVELOPER_MODE set to true. In developer mode you receive all warnings for anything that could be wrong, and have a small window in the leftbottom corner that shows you interesting information about the current state of the application, including current module, page, debugging info, and the content of all relevant SESSION vars. While on developer mode, you'll have access to all modules and sections, even those that are not ready for production. You can even take your working copy (unless you've got fatal errors around, of course) at any time down to production without risking to expose under-construction pages, modules or features. Any new page or module has permissions automatically assigned and you have to explicitly allow users to access them. You, on the other hand, as developer, need nothing to have it working for you.

Other automated features of AT include validation of input, loading animations when tasks are being performed, and integrity check of the application itself.




API Documentation